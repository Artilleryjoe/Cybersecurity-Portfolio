#!/usr/bin/env python3

import argparse
import json
from pathlib import Path
from typing import Any, Dict, List

DEFAULT_DB = [
    {
        "product": "apache httpd",
        "aliases": ["apache", "httpd"],
        "versions": {
            "2.4.41": [
                {
                    "cve": "CVE-2021-41773",
                    "cvss": 7.5,
                    "description": "Path traversal and file disclosure",
                    "mitre_attack": ["T1190"],
                },
                {
                    "cve": "CVE-2021-42013",
                    "cvss": 8.1,
                    "description": "Remote code execution via crafted path",
                    "mitre_attack": ["T1190"],
                },
            ]
        },
    },
    {
        "product": "nginx",
        "versions": {
            "1.18.0": [
                {
                    "cve": "CVE-2021-23017",
                    "cvss": 7.3,
                    "description": "1-byte memory overwrite in resolver",
                    "mitre_attack": ["T1190"],
                }
            ]
        },
    },
    {
        "product": "openssh",
        "versions": {
            "7.4": [
                {
                    "cve": "CVE-2018-15473",
                    "cvss": 5.3,
                    "description": "User enumeration via different responses",
                    "mitre_attack": ["T1082"],
                }
            ]
        },
    },
]


def load_scan_data(input_file: str | Path) -> Dict[str, Any]:
    with open(input_file, 'r', encoding='utf-8') as f:
        data = json.load(f)
    return data


def load_vuln_db(path: str | Path | None) -> List[dict]:
    if not path:
        return DEFAULT_DB
    db_path = Path(path)
    with open(db_path, 'r', encoding='utf-8') as f:
        payload = json.load(f)
    if not isinstance(payload, list):
        raise SystemExit("Custom CVE database must be a list of product entries")
    return payload


def _normalize(value: str) -> str:
    return value.lower().strip()


def find_exploits(service_name: str, version: str, database: List[dict]):
    product_norm = _normalize(service_name)
    version_norm = _normalize(version)
    matches: List[dict] = []
    for entry in database:
        names = [_normalize(entry.get("product", ""))]
        names.extend(_normalize(alias) for alias in entry.get("aliases", []))
        if not any(name and name in product_norm for name in names):
            continue
        version_map = entry.get("versions", {})
        for affected_version, vulns in version_map.items():
            affected_norm = _normalize(affected_version)
            if version_norm.startswith(affected_norm):
                matches.extend(vulns)
    return matches


def check_services(scan_data, database, min_score: float) -> List[dict]:
    results = []

    for host, info in scan_data.items():
        services = info.get('data') or []
        for service in services:
            product = service.get('product')
            version = service.get('version', '')
            port = service.get('port')
            if product and version:
                cves = [cve for cve in find_exploits(product, version, database) if cve.get('cvss', 0) >= min_score]
                if cves:
                    max_score = max(cve.get('cvss', 0) for cve in cves)
                    results.append({
                        'host': host,
                        'port': port,
                        'service': product,
                        'version': version,
                        'max_cvss': max_score,
                        'cves': cves,
                    })
    return results

def main():
    parser = argparse.ArgumentParser(description="Match discovered services against known CVEs/exploits.")
    parser.add_argument('-i', '--input', required=True, help="Input JSON file with service scan data")
    parser.add_argument('-o', '--output', help="Output JSON file for results (optional)")
    parser.add_argument('--cve-db', help="Optional JSON file with custom CVE mapping")
    parser.add_argument('--min-score', type=float, default=0.0, help="Minimum CVSS score to report")

    args = parser.parse_args()
    scan_data = load_scan_data(args.input)
    database = load_vuln_db(args.cve_db)
    exploits = check_services(scan_data, database, args.min_score)

    if args.output:
        with open(args.output, 'w', encoding='utf-8') as f:
            json.dump(exploits, f, indent=4)
        print(f"[+] Results saved to {args.output}")
    else:
        print(json.dumps(exploits, indent=4))

if __name__ == "__main__":
    main()
