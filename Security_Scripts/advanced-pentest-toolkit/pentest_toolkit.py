#!/usr/bin/env python3
"""Advanced Penetration Testing Toolkit utilities.

This module exposes a tiny automation layer around Metasploit's RPC interface
and now also provides a CLI helper that can run single exploits or execute
batch definitions from JSON.  Random delays and optional dry-run capabilities
help model stealthier operations while still being testable in CI systems where
Metasploit is not available.

Use only on systems you are authorized to test.
"""
from __future__ import annotations

import argparse
import json
import logging
import random
import time
from dataclasses import dataclass, field
from pathlib import Path
from typing import Iterable, List, Sequence

try:
    from metasploit.msfrpc import MsfRpcClient  # type: ignore
except Exception:  # pragma: no cover - library may not be installed
    MsfRpcClient = None  # type: ignore


@dataclass
class AttackTask:
    """Describe a single exploit invocation."""

    target: str
    exploit: str
    payload: str
    options: dict[str, str] = field(default_factory=dict)


class AttackAutomator:
    """Wrapper around Metasploit's RPC client to automate exploit runs."""

    def __init__(self, password: str, server: str = "127.0.0.1", port: int = 55553, ssl: bool = True) -> None:
        if MsfRpcClient is None:
            raise RuntimeError("metasploit.msfrpc module not available")
        self.client = MsfRpcClient(password, server=server, port=port, ssl=ssl)
        self.logger = logging.getLogger(__name__)

    def execute_task(self, task: AttackTask) -> str:
        """Run an exploit against a target with random delays for evasion."""

        console = self.client.consoles.console()
        self.logger.info("Launching %s against %s", task.exploit, task.target)
        console.write(f"use {task.exploit}\n")
        console.write(f"set RHOSTS {task.target}\n")
        console.write(f"set PAYLOAD {task.payload}\n")
        for key, value in task.options.items():
            console.write(f"set {key} {value}\n")
        console.write("run\n")
        self._random_delay()
        result = console.read().get("data", "")
        console.destroy()
        return result

    @staticmethod
    def _random_delay() -> None:
        time.sleep(random.uniform(0.5, 2.5))


class DryRunAutomator:
    """Fallback executor for environments without Metasploit."""

    def __init__(self) -> None:
        self.logger = logging.getLogger(__name__)

    def execute_task(self, task: AttackTask) -> str:  # pragma: no cover - simple logging
        summary = (
            f"DRY RUN -> exploit={task.exploit}, payload={task.payload}, target={task.target}, "
            f"options={task.options or '{}'}"
        )
        self.logger.info(summary)
        # Return summary so batch operations still have deterministic output
        return summary


def _parse_options(option_pairs: Sequence[str]) -> dict[str, str]:
    options: dict[str, str] = {}
    for raw in option_pairs:
        if "=" not in raw:
            raise ValueError(f"Invalid option '{raw}'. Expected KEY=VALUE format.")
        key, value = raw.split("=", 1)
        key = key.strip().upper()
        value = value.strip()
        if not key or not value:
            raise ValueError(f"Invalid option '{raw}'. Empty key/value not allowed.")
        options[key] = value
    return options


def _load_tasks_from_file(path: Path) -> List[AttackTask]:
    payload = json.loads(path.read_text())
    if not isinstance(payload, list):
        raise ValueError("Task file must contain a list of task definitions")
    tasks: List[AttackTask] = []
    for entry in payload:
        if not isinstance(entry, dict):
            raise ValueError("Each task entry must be a JSON object")
        try:
            task = AttackTask(
                target=entry["target"],
                exploit=entry["exploit"],
                payload=entry["payload"],
                options={k.upper(): str(v) for k, v in entry.get("options", {}).items()},
            )
        except KeyError as exc:
            raise ValueError(f"Missing required field in task definition: {exc}") from exc
        tasks.append(task)
    return tasks


def _build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(description="Automate Metasploit RPC operations with optional dry runs.")
    parser.add_argument("--password", help="Metasploit RPC password. Optional in --dry-run mode.")
    parser.add_argument("--server", default="127.0.0.1", help="Metasploit RPC server address.")
    parser.add_argument("--port", default=55553, type=int, help="Metasploit RPC port (default: 55553).")
    parser.add_argument("--no-ssl", dest="ssl", action="store_false", help="Disable SSL for RPC communication.")
    parser.add_argument("--dry-run", action="store_true", help="Do not execute commands, just log actions.")

    task_group = parser.add_mutually_exclusive_group(required=True)
    task_group.add_argument(
        "--task",
        nargs=3,
        metavar=("TARGET", "EXPLOIT", "PAYLOAD"),
        help="Execute a single exploit run with inline parameters.",
    )
    task_group.add_argument(
        "--task-file",
        type=Path,
        help="Path to a JSON file describing a list of tasks.",
    )
    parser.add_argument(
        "--option",
        action="append",
        default=[],
        metavar="KEY=VALUE",
        help="Additional Metasploit options for the inline --task version.",
    )
    return parser


def _select_executor(args: argparse.Namespace):
    if args.dry_run:
        return DryRunAutomator()
    if args.password is None:
        raise SystemExit("--password is required unless --dry-run is supplied")
    return AttackAutomator(args.password, server=args.server, port=args.port, ssl=args.ssl)


def _collect_tasks(args: argparse.Namespace) -> List[AttackTask]:
    if args.task:
        options = _parse_options(args.option)
        return [AttackTask(target=args.task[0], exploit=args.task[1], payload=args.task[2], options=options)]
    if args.task_file:
        return _load_tasks_from_file(args.task_file)
    raise SystemExit("Either --task or --task-file must be supplied")


def run_cli(argv: Sequence[str] | None = None) -> None:
    parser = _build_parser()
    args = parser.parse_args(argv)
    executor = _select_executor(args)
    tasks = _collect_tasks(args)
    for task in tasks:
        result = executor.execute_task(task)
        print(result)


if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO, format="%(levelname)s: %(message)s")
    run_cli()
